//------------------------------------------------
//      File: resources.bt
//   Authors: JanDK
//   Version: 0.1
//   Purpose: Template for .resources from DOOM: Eternal
//  Category: Archive
// File Mask: *.resources
//  ID Bytes: 49 44 43 4C
//------------------------------------------------

enum <ubyte> ResourceCompressionMode {
    RES_COMP_MODE_NONE = 0,
    RES_COMP_MODE_ZLIB = 1,
    RES_COMP_MODE_KRAKEN = 2,
    RES_COMP_MODE_LZNA = 3,
    RES_COMP_MODE_KRAKEN_CHUNKED = 4,
    RES_COMP_MODE_LEVIATHAN = 5,
    RES_COMP_MODE_ENUM_MAX = 6,
};

// idResourceHeader
struct ResourcesHeader {
    uint magic;
    uint version;
    Assert(magic   == 0x4c434449);
    Assert(version == 12);

    uint  flags;
    uint  numSegments;
    uquad segmentSize;
    uquad metadataHash;
    Assert(flags        == 0);
    Assert(numSegments  == 1);
    Assert(segmentSize  == 0xffffffffffL);
    Assert(metadataHash == 0);

    uint  numResources;
    uint  numDependencies;
    uint  numDepIndices;
    uint  numStringIndices;
    uint  numSpecialHashes;
    uint  numMetaEntries;
    uint  stringTableSize;
    uint  metaEntriesSize;
    Assert(numSpecialHashes == 0);
    Assert(numMetaEntries   == 0);
    Assert(metaEntriesSize  == 0);

    uquad stringTableOffset;
    uquad metaEntriesOffset;
    uquad resourceEntriesOffset;
    uquad resourceDepsOffset;
    uquad resourceSpecialHashOffset;

    uquad dataOffset;
    uint  unknown;
    uquad metaSize;
    Assert(unknown == 0);
};

struct ResourcesEntry
{
	quad   resourceTypeString;
	quad   nameString;
	quad   descString;
	uquad  depIndices;
	uquad  strings;
	uquad  specialHashes;
	uquad  metaEntries;
	uquad  dataOffset;
	uquad  dataSize;
    Assert(resourceTypeString == 0);
    Assert(nameString         == 1);
    Assert(descString         == -1);
    Assert(specialHashes      == 0);
    Assert(metaEntries        == 0);

	uquad  uncompressedSize;
	uquad  dataCheckSum;
	uquad  generationTimeStamp;
	uquad  defaultHash;
	uint   version;
	uint   flags;
	ResourceCompressionMode compMode;
	ubyte  reserved0;
	ushort variation;
	uint   reserved2;
	uquad  reservedForVariations;
    Assert(reserved0             == 0);
    Assert(reserved2             == 0);
    Assert(reservedForVariations == 0);

	ushort numStrings;
	ushort numSources;
	ushort numDependencies;
	ushort numSpecialHashes;
	ushort numMetaEntries;
    uint   padding1;
    ushort padding2;
    Assert(numStrings       == 2);
    Assert(numSpecialHashes == 0);
    Assert(numMetaEntries   == 0);
    Assert(padding1         == 0);
    Assert(padding2         == 0);
};

typedef struct {
    string value;
} WrappedString <read=this.value>;

struct ResourcesStrings {
    uint64 numStrings;
    uint64 offsets[numStrings];
    WrappedString values[numStrings] <optimize=false>;
};

struct ResourcesDependency {
	uint64 type;
	uint64 name;
	uint32 depType;
	uint32 depSubType;
	uint64 hashOrTimestamp;
};

struct Resources {
    ResourcesHeader header <style=sHeading1>;

    FSeek(header.resourceEntriesOffset);
    ResourcesEntry entries[header.numResources] <style=sHeading2>;

    FSeek(header.stringTableOffset);
    ResourcesStrings strings <style=sHeading3>;

    FSeek(header.resourceDepsOffset);
    ResourcesDependency dependencies[header.numDependencies] <style=sHeading4>;
    uint32 dependencyIndex[header.numDepIndices] <style=sHeading1>;
    uint64 stringIndex[header.numStringIndices] <style=sHeading2>;
} resourceStorage;
