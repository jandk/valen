typedef ubyte bool8;

enum TextureType {
    TT_2D = 0,
    TT_3D = 1,
    TT_CUBIC = 2,
};

enum TextureMaterialKind {
    TMK_NONE = 0,
    TMK_ALBEDO = 1,
    TMK_SPECULAR = 2,
    TMK_NORMAL = 3,
    TMK_SMOOTHNESS = 4,
    TMK_COVER = 5,
    TMK_SSSMASK = 6,
    TMK_COLORMASK = 7,
    TMK_BLOOMMASK = 8,
    TMK_HEIGHTMAP = 9,
    TMK_DECALALBEDO = 10,
    TMK_DECALNORMAL = 11,
    TMK_DECALSPECULAR = 12,
    TMK_LIGHTPROJECT = 13,
    TMK_PARTICLE = 14,
    TMK_UNUSED_1 = 15,
    TMK_UNUSED_2 = 16,
    TMK_LIGHTMAP = 17,
    TMK_UI = 18,
    TMK_FONT = 19,
    TMK_LEGACY_FLASH_UI = 20,
    TMK_LIGHTMAP_DIRECTIONAL = 21,
    TMK_BLENDMASK = 22,
    TMK_COUNT = 23,
};

enum TextureFormat {
    FMT_NONE = 0,
    FMT_RGBA32F = 1,
    FMT_RGBA16F = 2,
    FMT_RGBA8 = 3,
    FMT_RGBA8_SRGB = 32,
    FMT_ARGB8 = 4,
    FMT_ALPHA = 5,
    FMT_L8A8_DEPRECATED = 6,
    FMT_RG8 = 7,
    FMT_LUM8_DEPRECATED = 8,
    FMT_INT8_DEPRECATED = 9,
    FMT_BC1 = 10,
    FMT_BC1_SRGB = 33,
    FMT_BC1_ZERO_ALPHA = 54,
    FMT_BC3 = 11,
    FMT_BC3_SRGB = 34,
    FMT_BC4 = 24,
    FMT_BC5 = 25,
    FMT_BC6H_UF16 = 22,
    FMT_BC6H_SF16 = 36,
    FMT_BC7 = 23,
    FMT_BC7_SRGB = 35,
    FMT_DEPTH = 12,
    FMT_DEPTH_STENCIL = 13,
    FMT_DEPTH16 = 31,
    FMT_X32F = 14,
    FMT_Y16F_X16F = 15,
    FMT_X16 = 16,
    FMT_Y16_X16 = 17,
    FMT_RGB565 = 18,
    FMT_R8 = 19,
    FMT_R11FG11FB10F = 20,
    FMT_X16F = 21,
    FMT_RG16F = 26,
    FMT_R10G10B10A2 = 27,
    FMT_RG32F = 28,
    FMT_R32_UINT = 29,
    FMT_R16_UINT = 30,
    FMT_R8_UINT = 55,
    FMT_ASTC_4X4 = 37,
    FMT_ASTC_4X4_SRGB = 38,
    FMT_ASTC_5X4 = 39,
    FMT_ASTC_5X4_SRGB = 40,
    FMT_ASTC_5X5 = 41,
    FMT_ASTC_5X5_SRGB = 42,
    FMT_ASTC_6X5 = 43,
    FMT_ASTC_6X5_SRGB = 44,
    FMT_ASTC_6X6 = 45,
    FMT_ASTC_6X6_SRGB = 46,
    FMT_ASTC_8X5 = 47,
    FMT_ASTC_8X5_SRGB = 48,
    FMT_ASTC_8X6 = 49,
    FMT_ASTC_8X6_SRGB = 50,
    FMT_ASTC_8X8 = 51,
    FMT_ASTC_8X8_SRGB = 52,
    FMT_DEPTH32F = 53,
    FMT_NEXTAVAILABLE = 56,
};

struct ImageHeader {
    ubyte magic0;
    ubyte magic1;
    ubyte magic2;
    ubyte version;
    Assert(magic0 == 0x42); // B
    Assert(magic1 == 0x49); // I
    Assert(magic2 == 0x4D); // M
    
    TextureType textureType;
    TextureMaterialKind textureMaterialKind;
    uint  pixelWidth;
    uint  pixelHeight;
    uint  depth;
    uint  mipCount;
    uint  unkFlags;
    float albedoSpecularBias;
    float albedoSpecularScale;
    ubyte padding1;
    TextureFormat textureFormat;
    uint   always7;
    uint   padding2;
    ushort padding3;
    bool8  streamed;
    bool8  singleStream;
    bool8  noMips;
    bool8  fftBloom;
    uint   streamDbMipCount;
    Assert(padding1 == 0);
    Assert(always7  == 7);
    Assert(padding2 == 0);
    Assert(padding3 == 0);
};

struct ImageMipInfo {
    uint mipLevel;
    uint mipSlice;
    uint mipPixelWidth;
    uint mipPixelHeight;
    uint always1;
    uint decompressedSize;
    uint flagIsCompressed;
    uint compressedSize;
    uint cumulativeSizeStreamDb;
    
    Assert(always1 == 1);
};

struct Image {
    ImageHeader header <style=sHeading1>;
    ImageMipInfo mipInfos[header.mipCount] <style=sHeading2, optimize=false>;
    
    /* For loops not supported yet */
    /*
    for (int i = header.streamDbMipCount; i < header.mipCount; i++) {
        struct ImageMip {
            byte mip[mipInfos[i].decompressedSize];
        } mip <style=sSection1>;
    }
    */
} image;
